/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var google_protobuf_empty_pb = require('google-protobuf/google/protobuf/empty_pb.js');
goog.object.extend(proto, google_protobuf_empty_pb);
goog.exportSymbol('proto.ethereum.beacon.rpc.v1.Attestation', null, global);
goog.exportSymbol('proto.ethereum.beacon.rpc.v1.AttestationData', null, global);
goog.exportSymbol('proto.ethereum.beacon.rpc.v1.AttesterSlashing', null, global);
goog.exportSymbol('proto.ethereum.beacon.rpc.v1.BeaconBlock', null, global);
goog.exportSymbol('proto.ethereum.beacon.rpc.v1.BeaconBlockBody', null, global);
goog.exportSymbol('proto.ethereum.beacon.rpc.v1.BlockTreeResponse', null, global);
goog.exportSymbol('proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode', null, global);
goog.exportSymbol('proto.ethereum.beacon.rpc.v1.Crosslink', null, global);
goog.exportSymbol('proto.ethereum.beacon.rpc.v1.Deposit', null, global);
goog.exportSymbol('proto.ethereum.beacon.rpc.v1.Eth1Data', null, global);
goog.exportSymbol('proto.ethereum.beacon.rpc.v1.Eth1DataVote', null, global);
goog.exportSymbol('proto.ethereum.beacon.rpc.v1.ProposalSignedData', null, global);
goog.exportSymbol('proto.ethereum.beacon.rpc.v1.ProposerSlashing', null, global);
goog.exportSymbol('proto.ethereum.beacon.rpc.v1.SlashableAttestation', null, global);
goog.exportSymbol('proto.ethereum.beacon.rpc.v1.VoluntaryExit', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.ethereum.beacon.rpc.v1.BlockTreeResponse.repeatedFields_, null);
};
goog.inherits(proto.ethereum.beacon.rpc.v1.BlockTreeResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ethereum.beacon.rpc.v1.BlockTreeResponse.displayName = 'proto.ethereum.beacon.rpc.v1.BlockTreeResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.displayName = 'proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ethereum.beacon.rpc.v1.BeaconBlock, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ethereum.beacon.rpc.v1.BeaconBlock.displayName = 'proto.ethereum.beacon.rpc.v1.BeaconBlock';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.ethereum.beacon.rpc.v1.BeaconBlockBody.repeatedFields_, null);
};
goog.inherits(proto.ethereum.beacon.rpc.v1.BeaconBlockBody, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ethereum.beacon.rpc.v1.BeaconBlockBody.displayName = 'proto.ethereum.beacon.rpc.v1.BeaconBlockBody';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ethereum.beacon.rpc.v1.Attestation = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ethereum.beacon.rpc.v1.Attestation, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ethereum.beacon.rpc.v1.Attestation.displayName = 'proto.ethereum.beacon.rpc.v1.Attestation';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ethereum.beacon.rpc.v1.AttestationData = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ethereum.beacon.rpc.v1.AttestationData, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ethereum.beacon.rpc.v1.AttestationData.displayName = 'proto.ethereum.beacon.rpc.v1.AttestationData';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ethereum.beacon.rpc.v1.ProposalSignedData = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ethereum.beacon.rpc.v1.ProposalSignedData, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ethereum.beacon.rpc.v1.ProposalSignedData.displayName = 'proto.ethereum.beacon.rpc.v1.ProposalSignedData';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.ethereum.beacon.rpc.v1.SlashableAttestation.repeatedFields_, null);
};
goog.inherits(proto.ethereum.beacon.rpc.v1.SlashableAttestation, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ethereum.beacon.rpc.v1.SlashableAttestation.displayName = 'proto.ethereum.beacon.rpc.v1.SlashableAttestation';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ethereum.beacon.rpc.v1.ProposerSlashing, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ethereum.beacon.rpc.v1.ProposerSlashing.displayName = 'proto.ethereum.beacon.rpc.v1.ProposerSlashing';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ethereum.beacon.rpc.v1.AttesterSlashing = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ethereum.beacon.rpc.v1.AttesterSlashing, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ethereum.beacon.rpc.v1.AttesterSlashing.displayName = 'proto.ethereum.beacon.rpc.v1.AttesterSlashing';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ethereum.beacon.rpc.v1.Crosslink = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ethereum.beacon.rpc.v1.Crosslink, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ethereum.beacon.rpc.v1.Crosslink.displayName = 'proto.ethereum.beacon.rpc.v1.Crosslink';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ethereum.beacon.rpc.v1.Deposit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.ethereum.beacon.rpc.v1.Deposit.repeatedFields_, null);
};
goog.inherits(proto.ethereum.beacon.rpc.v1.Deposit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ethereum.beacon.rpc.v1.Deposit.displayName = 'proto.ethereum.beacon.rpc.v1.Deposit';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ethereum.beacon.rpc.v1.VoluntaryExit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ethereum.beacon.rpc.v1.VoluntaryExit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ethereum.beacon.rpc.v1.VoluntaryExit.displayName = 'proto.ethereum.beacon.rpc.v1.VoluntaryExit';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ethereum.beacon.rpc.v1.Eth1Data = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ethereum.beacon.rpc.v1.Eth1Data, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ethereum.beacon.rpc.v1.Eth1Data.displayName = 'proto.ethereum.beacon.rpc.v1.Eth1Data';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ethereum.beacon.rpc.v1.Eth1DataVote = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ethereum.beacon.rpc.v1.Eth1DataVote, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ethereum.beacon.rpc.v1.Eth1DataVote.displayName = 'proto.ethereum.beacon.rpc.v1.Eth1DataVote';
}

/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.ethereum.beacon.rpc.v1.BlockTreeResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ethereum.beacon.rpc.v1.BlockTreeResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    treeList: jspb.Message.toObjectList(msg.getTreeList(),
    proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ethereum.beacon.rpc.v1.BlockTreeResponse}
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ethereum.beacon.rpc.v1.BlockTreeResponse;
  return proto.ethereum.beacon.rpc.v1.BlockTreeResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ethereum.beacon.rpc.v1.BlockTreeResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ethereum.beacon.rpc.v1.BlockTreeResponse}
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode;
      reader.readMessage(value,proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.deserializeBinaryFromReader);
      msg.addTree(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ethereum.beacon.rpc.v1.BlockTreeResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ethereum.beacon.rpc.v1.BlockTreeResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTreeList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.serializeBinaryToWriter
    );
  }
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.prototype.toObject = function(opt_includeInstance) {
  return proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    block: (f = msg.getBlock()) && proto.ethereum.beacon.rpc.v1.BeaconBlock.toObject(includeInstance, f),
    blockRoot: msg.getBlockRoot_asB64(),
    participatedVotes: jspb.Message.getFieldWithDefault(msg, 3, 0),
    totalVotes: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode}
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode;
  return proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode}
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.ethereum.beacon.rpc.v1.BeaconBlock;
      reader.readMessage(value,proto.ethereum.beacon.rpc.v1.BeaconBlock.deserializeBinaryFromReader);
      msg.setBlock(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBlockRoot(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setParticipatedVotes(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setTotalVotes(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBlock();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.ethereum.beacon.rpc.v1.BeaconBlock.serializeBinaryToWriter
    );
  }
  f = message.getBlockRoot_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getParticipatedVotes();
  if (f !== 0) {
    writer.writeUint64(
      3,
      f
    );
  }
  f = message.getTotalVotes();
  if (f !== 0) {
    writer.writeUint64(
      4,
      f
    );
  }
};


/**
 * optional BeaconBlock block = 1;
 * @return {?proto.ethereum.beacon.rpc.v1.BeaconBlock}
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.prototype.getBlock = function() {
  return /** @type{?proto.ethereum.beacon.rpc.v1.BeaconBlock} */ (
    jspb.Message.getWrapperField(this, proto.ethereum.beacon.rpc.v1.BeaconBlock, 1));
};


/** @param {?proto.ethereum.beacon.rpc.v1.BeaconBlock|undefined} value */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.prototype.setBlock = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.prototype.clearBlock = function() {
  this.setBlock(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.prototype.hasBlock = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes block_root = 2;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.prototype.getBlockRoot = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes block_root = 2;
 * This is a type-conversion wrapper around `getBlockRoot()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.prototype.getBlockRoot_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBlockRoot()));
};


/**
 * optional bytes block_root = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBlockRoot()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.prototype.getBlockRoot_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBlockRoot()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.prototype.setBlockRoot = function(value) {
  jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional uint64 participated_votes = 3;
 * @return {number}
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.prototype.getParticipatedVotes = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.prototype.setParticipatedVotes = function(value) {
  jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional uint64 total_votes = 4;
 * @return {number}
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.prototype.getTotalVotes = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode.prototype.setTotalVotes = function(value) {
  jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * repeated TreeNode tree = 1;
 * @return {!Array<!proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode>}
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.prototype.getTreeList = function() {
  return /** @type{!Array<!proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode, 1));
};


/** @param {!Array<!proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode>} value */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.prototype.setTreeList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode=} opt_value
 * @param {number=} opt_index
 * @return {!proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode}
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.prototype.addTree = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.ethereum.beacon.rpc.v1.BlockTreeResponse.TreeNode, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 */
proto.ethereum.beacon.rpc.v1.BlockTreeResponse.prototype.clearTreeList = function() {
  this.setTreeList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.toObject = function(opt_includeInstance) {
  return proto.ethereum.beacon.rpc.v1.BeaconBlock.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ethereum.beacon.rpc.v1.BeaconBlock} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.toObject = function(includeInstance, msg) {
  var f, obj = {
    slot: jspb.Message.getFieldWithDefault(msg, 1, "0"),
    parentRootHash32: msg.getParentRootHash32_asB64(),
    stateRootHash32: msg.getStateRootHash32_asB64(),
    randaoReveal: msg.getRandaoReveal_asB64(),
    eth1Data: (f = msg.getEth1Data()) && proto.ethereum.beacon.rpc.v1.Eth1Data.toObject(includeInstance, f),
    signature: msg.getSignature_asB64(),
    body: (f = msg.getBody()) && proto.ethereum.beacon.rpc.v1.BeaconBlockBody.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ethereum.beacon.rpc.v1.BeaconBlock}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ethereum.beacon.rpc.v1.BeaconBlock;
  return proto.ethereum.beacon.rpc.v1.BeaconBlock.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ethereum.beacon.rpc.v1.BeaconBlock} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ethereum.beacon.rpc.v1.BeaconBlock}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setSlot(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setParentRootHash32(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setStateRootHash32(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setRandaoReveal(value);
      break;
    case 5:
      var value = new proto.ethereum.beacon.rpc.v1.Eth1Data;
      reader.readMessage(value,proto.ethereum.beacon.rpc.v1.Eth1Data.deserializeBinaryFromReader);
      msg.setEth1Data(value);
      break;
    case 6:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    case 7:
      var value = new proto.ethereum.beacon.rpc.v1.BeaconBlockBody;
      reader.readMessage(value,proto.ethereum.beacon.rpc.v1.BeaconBlockBody.deserializeBinaryFromReader);
      msg.setBody(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ethereum.beacon.rpc.v1.BeaconBlock.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ethereum.beacon.rpc.v1.BeaconBlock} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSlot();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      1,
      f
    );
  }
  f = message.getParentRootHash32_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getStateRootHash32_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getRandaoReveal_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = message.getEth1Data();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.ethereum.beacon.rpc.v1.Eth1Data.serializeBinaryToWriter
    );
  }
  f = message.getSignature_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      6,
      f
    );
  }
  f = message.getBody();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      proto.ethereum.beacon.rpc.v1.BeaconBlockBody.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint64 slot = 1;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.getSlot = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "0"));
};


/** @param {string} value */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.setSlot = function(value) {
  jspb.Message.setProto3StringIntField(this, 1, value);
};


/**
 * optional bytes parent_root_hash32 = 2;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.getParentRootHash32 = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes parent_root_hash32 = 2;
 * This is a type-conversion wrapper around `getParentRootHash32()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.getParentRootHash32_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getParentRootHash32()));
};


/**
 * optional bytes parent_root_hash32 = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getParentRootHash32()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.getParentRootHash32_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getParentRootHash32()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.setParentRootHash32 = function(value) {
  jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional bytes state_root_hash32 = 3;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.getStateRootHash32 = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes state_root_hash32 = 3;
 * This is a type-conversion wrapper around `getStateRootHash32()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.getStateRootHash32_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getStateRootHash32()));
};


/**
 * optional bytes state_root_hash32 = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getStateRootHash32()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.getStateRootHash32_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getStateRootHash32()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.setStateRootHash32 = function(value) {
  jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional bytes randao_reveal = 4;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.getRandaoReveal = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes randao_reveal = 4;
 * This is a type-conversion wrapper around `getRandaoReveal()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.getRandaoReveal_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getRandaoReveal()));
};


/**
 * optional bytes randao_reveal = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getRandaoReveal()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.getRandaoReveal_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getRandaoReveal()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.setRandaoReveal = function(value) {
  jspb.Message.setProto3BytesField(this, 4, value);
};


/**
 * optional Eth1Data eth1_data = 5;
 * @return {?proto.ethereum.beacon.rpc.v1.Eth1Data}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.getEth1Data = function() {
  return /** @type{?proto.ethereum.beacon.rpc.v1.Eth1Data} */ (
    jspb.Message.getWrapperField(this, proto.ethereum.beacon.rpc.v1.Eth1Data, 5));
};


/** @param {?proto.ethereum.beacon.rpc.v1.Eth1Data|undefined} value */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.setEth1Data = function(value) {
  jspb.Message.setWrapperField(this, 5, value);
};


/**
 * Clears the message field making it undefined.
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.clearEth1Data = function() {
  this.setEth1Data(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.hasEth1Data = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional bytes signature = 6;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.getSignature = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * optional bytes signature = 6;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 6;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.setSignature = function(value) {
  jspb.Message.setProto3BytesField(this, 6, value);
};


/**
 * optional BeaconBlockBody body = 7;
 * @return {?proto.ethereum.beacon.rpc.v1.BeaconBlockBody}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.getBody = function() {
  return /** @type{?proto.ethereum.beacon.rpc.v1.BeaconBlockBody} */ (
    jspb.Message.getWrapperField(this, proto.ethereum.beacon.rpc.v1.BeaconBlockBody, 7));
};


/** @param {?proto.ethereum.beacon.rpc.v1.BeaconBlockBody|undefined} value */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.setBody = function(value) {
  jspb.Message.setWrapperField(this, 7, value);
};


/**
 * Clears the message field making it undefined.
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.clearBody = function() {
  this.setBody(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlock.prototype.hasBody = function() {
  return jspb.Message.getField(this, 7) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.repeatedFields_ = [1,2,3,4,5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.toObject = function(opt_includeInstance) {
  return proto.ethereum.beacon.rpc.v1.BeaconBlockBody.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ethereum.beacon.rpc.v1.BeaconBlockBody} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.toObject = function(includeInstance, msg) {
  var f, obj = {
    attestationsList: jspb.Message.toObjectList(msg.getAttestationsList(),
    proto.ethereum.beacon.rpc.v1.Attestation.toObject, includeInstance),
    proposerSlashingsList: jspb.Message.toObjectList(msg.getProposerSlashingsList(),
    proto.ethereum.beacon.rpc.v1.ProposerSlashing.toObject, includeInstance),
    attesterSlashingsList: jspb.Message.toObjectList(msg.getAttesterSlashingsList(),
    proto.ethereum.beacon.rpc.v1.AttesterSlashing.toObject, includeInstance),
    depositsList: jspb.Message.toObjectList(msg.getDepositsList(),
    proto.ethereum.beacon.rpc.v1.Deposit.toObject, includeInstance),
    voluntaryExitsList: jspb.Message.toObjectList(msg.getVoluntaryExitsList(),
    proto.ethereum.beacon.rpc.v1.VoluntaryExit.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ethereum.beacon.rpc.v1.BeaconBlockBody}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ethereum.beacon.rpc.v1.BeaconBlockBody;
  return proto.ethereum.beacon.rpc.v1.BeaconBlockBody.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ethereum.beacon.rpc.v1.BeaconBlockBody} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ethereum.beacon.rpc.v1.BeaconBlockBody}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.ethereum.beacon.rpc.v1.Attestation;
      reader.readMessage(value,proto.ethereum.beacon.rpc.v1.Attestation.deserializeBinaryFromReader);
      msg.addAttestations(value);
      break;
    case 2:
      var value = new proto.ethereum.beacon.rpc.v1.ProposerSlashing;
      reader.readMessage(value,proto.ethereum.beacon.rpc.v1.ProposerSlashing.deserializeBinaryFromReader);
      msg.addProposerSlashings(value);
      break;
    case 3:
      var value = new proto.ethereum.beacon.rpc.v1.AttesterSlashing;
      reader.readMessage(value,proto.ethereum.beacon.rpc.v1.AttesterSlashing.deserializeBinaryFromReader);
      msg.addAttesterSlashings(value);
      break;
    case 4:
      var value = new proto.ethereum.beacon.rpc.v1.Deposit;
      reader.readMessage(value,proto.ethereum.beacon.rpc.v1.Deposit.deserializeBinaryFromReader);
      msg.addDeposits(value);
      break;
    case 5:
      var value = new proto.ethereum.beacon.rpc.v1.VoluntaryExit;
      reader.readMessage(value,proto.ethereum.beacon.rpc.v1.VoluntaryExit.deserializeBinaryFromReader);
      msg.addVoluntaryExits(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ethereum.beacon.rpc.v1.BeaconBlockBody.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ethereum.beacon.rpc.v1.BeaconBlockBody} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAttestationsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.ethereum.beacon.rpc.v1.Attestation.serializeBinaryToWriter
    );
  }
  f = message.getProposerSlashingsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.ethereum.beacon.rpc.v1.ProposerSlashing.serializeBinaryToWriter
    );
  }
  f = message.getAttesterSlashingsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.ethereum.beacon.rpc.v1.AttesterSlashing.serializeBinaryToWriter
    );
  }
  f = message.getDepositsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.ethereum.beacon.rpc.v1.Deposit.serializeBinaryToWriter
    );
  }
  f = message.getVoluntaryExitsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      5,
      f,
      proto.ethereum.beacon.rpc.v1.VoluntaryExit.serializeBinaryToWriter
    );
  }
};


/**
 * repeated Attestation attestations = 1;
 * @return {!Array<!proto.ethereum.beacon.rpc.v1.Attestation>}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.getAttestationsList = function() {
  return /** @type{!Array<!proto.ethereum.beacon.rpc.v1.Attestation>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.ethereum.beacon.rpc.v1.Attestation, 1));
};


/** @param {!Array<!proto.ethereum.beacon.rpc.v1.Attestation>} value */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.setAttestationsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.ethereum.beacon.rpc.v1.Attestation=} opt_value
 * @param {number=} opt_index
 * @return {!proto.ethereum.beacon.rpc.v1.Attestation}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.addAttestations = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.ethereum.beacon.rpc.v1.Attestation, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.clearAttestationsList = function() {
  this.setAttestationsList([]);
};


/**
 * repeated ProposerSlashing proposer_slashings = 2;
 * @return {!Array<!proto.ethereum.beacon.rpc.v1.ProposerSlashing>}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.getProposerSlashingsList = function() {
  return /** @type{!Array<!proto.ethereum.beacon.rpc.v1.ProposerSlashing>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.ethereum.beacon.rpc.v1.ProposerSlashing, 2));
};


/** @param {!Array<!proto.ethereum.beacon.rpc.v1.ProposerSlashing>} value */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.setProposerSlashingsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.ethereum.beacon.rpc.v1.ProposerSlashing=} opt_value
 * @param {number=} opt_index
 * @return {!proto.ethereum.beacon.rpc.v1.ProposerSlashing}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.addProposerSlashings = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.ethereum.beacon.rpc.v1.ProposerSlashing, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.clearProposerSlashingsList = function() {
  this.setProposerSlashingsList([]);
};


/**
 * repeated AttesterSlashing attester_slashings = 3;
 * @return {!Array<!proto.ethereum.beacon.rpc.v1.AttesterSlashing>}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.getAttesterSlashingsList = function() {
  return /** @type{!Array<!proto.ethereum.beacon.rpc.v1.AttesterSlashing>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.ethereum.beacon.rpc.v1.AttesterSlashing, 3));
};


/** @param {!Array<!proto.ethereum.beacon.rpc.v1.AttesterSlashing>} value */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.setAttesterSlashingsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.ethereum.beacon.rpc.v1.AttesterSlashing=} opt_value
 * @param {number=} opt_index
 * @return {!proto.ethereum.beacon.rpc.v1.AttesterSlashing}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.addAttesterSlashings = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.ethereum.beacon.rpc.v1.AttesterSlashing, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.clearAttesterSlashingsList = function() {
  this.setAttesterSlashingsList([]);
};


/**
 * repeated Deposit deposits = 4;
 * @return {!Array<!proto.ethereum.beacon.rpc.v1.Deposit>}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.getDepositsList = function() {
  return /** @type{!Array<!proto.ethereum.beacon.rpc.v1.Deposit>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.ethereum.beacon.rpc.v1.Deposit, 4));
};


/** @param {!Array<!proto.ethereum.beacon.rpc.v1.Deposit>} value */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.setDepositsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.ethereum.beacon.rpc.v1.Deposit=} opt_value
 * @param {number=} opt_index
 * @return {!proto.ethereum.beacon.rpc.v1.Deposit}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.addDeposits = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.ethereum.beacon.rpc.v1.Deposit, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.clearDepositsList = function() {
  this.setDepositsList([]);
};


/**
 * repeated VoluntaryExit voluntary_exits = 5;
 * @return {!Array<!proto.ethereum.beacon.rpc.v1.VoluntaryExit>}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.getVoluntaryExitsList = function() {
  return /** @type{!Array<!proto.ethereum.beacon.rpc.v1.VoluntaryExit>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.ethereum.beacon.rpc.v1.VoluntaryExit, 5));
};


/** @param {!Array<!proto.ethereum.beacon.rpc.v1.VoluntaryExit>} value */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.setVoluntaryExitsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 5, value);
};


/**
 * @param {!proto.ethereum.beacon.rpc.v1.VoluntaryExit=} opt_value
 * @param {number=} opt_index
 * @return {!proto.ethereum.beacon.rpc.v1.VoluntaryExit}
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.addVoluntaryExits = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.ethereum.beacon.rpc.v1.VoluntaryExit, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 */
proto.ethereum.beacon.rpc.v1.BeaconBlockBody.prototype.clearVoluntaryExitsList = function() {
  this.setVoluntaryExitsList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ethereum.beacon.rpc.v1.Attestation.prototype.toObject = function(opt_includeInstance) {
  return proto.ethereum.beacon.rpc.v1.Attestation.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ethereum.beacon.rpc.v1.Attestation} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.Attestation.toObject = function(includeInstance, msg) {
  var f, obj = {
    data: (f = msg.getData()) && proto.ethereum.beacon.rpc.v1.AttestationData.toObject(includeInstance, f),
    aggregationBitfield: msg.getAggregationBitfield_asB64(),
    custodyBitfield: msg.getCustodyBitfield_asB64(),
    aggregateSignature: msg.getAggregateSignature_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ethereum.beacon.rpc.v1.Attestation}
 */
proto.ethereum.beacon.rpc.v1.Attestation.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ethereum.beacon.rpc.v1.Attestation;
  return proto.ethereum.beacon.rpc.v1.Attestation.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ethereum.beacon.rpc.v1.Attestation} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ethereum.beacon.rpc.v1.Attestation}
 */
proto.ethereum.beacon.rpc.v1.Attestation.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.ethereum.beacon.rpc.v1.AttestationData;
      reader.readMessage(value,proto.ethereum.beacon.rpc.v1.AttestationData.deserializeBinaryFromReader);
      msg.setData(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setAggregationBitfield(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setCustodyBitfield(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setAggregateSignature(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.Attestation.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ethereum.beacon.rpc.v1.Attestation.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ethereum.beacon.rpc.v1.Attestation} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.Attestation.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getData();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.ethereum.beacon.rpc.v1.AttestationData.serializeBinaryToWriter
    );
  }
  f = message.getAggregationBitfield_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getCustodyBitfield_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getAggregateSignature_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
};


/**
 * optional AttestationData data = 1;
 * @return {?proto.ethereum.beacon.rpc.v1.AttestationData}
 */
proto.ethereum.beacon.rpc.v1.Attestation.prototype.getData = function() {
  return /** @type{?proto.ethereum.beacon.rpc.v1.AttestationData} */ (
    jspb.Message.getWrapperField(this, proto.ethereum.beacon.rpc.v1.AttestationData, 1));
};


/** @param {?proto.ethereum.beacon.rpc.v1.AttestationData|undefined} value */
proto.ethereum.beacon.rpc.v1.Attestation.prototype.setData = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 */
proto.ethereum.beacon.rpc.v1.Attestation.prototype.clearData = function() {
  this.setData(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ethereum.beacon.rpc.v1.Attestation.prototype.hasData = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes aggregation_bitfield = 2;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.Attestation.prototype.getAggregationBitfield = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes aggregation_bitfield = 2;
 * This is a type-conversion wrapper around `getAggregationBitfield()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.Attestation.prototype.getAggregationBitfield_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getAggregationBitfield()));
};


/**
 * optional bytes aggregation_bitfield = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getAggregationBitfield()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.Attestation.prototype.getAggregationBitfield_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getAggregationBitfield()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.Attestation.prototype.setAggregationBitfield = function(value) {
  jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional bytes custody_bitfield = 3;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.Attestation.prototype.getCustodyBitfield = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes custody_bitfield = 3;
 * This is a type-conversion wrapper around `getCustodyBitfield()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.Attestation.prototype.getCustodyBitfield_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getCustodyBitfield()));
};


/**
 * optional bytes custody_bitfield = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getCustodyBitfield()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.Attestation.prototype.getCustodyBitfield_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getCustodyBitfield()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.Attestation.prototype.setCustodyBitfield = function(value) {
  jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional bytes aggregate_signature = 4;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.Attestation.prototype.getAggregateSignature = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes aggregate_signature = 4;
 * This is a type-conversion wrapper around `getAggregateSignature()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.Attestation.prototype.getAggregateSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getAggregateSignature()));
};


/**
 * optional bytes aggregate_signature = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getAggregateSignature()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.Attestation.prototype.getAggregateSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getAggregateSignature()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.Attestation.prototype.setAggregateSignature = function(value) {
  jspb.Message.setProto3BytesField(this, 4, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.toObject = function(opt_includeInstance) {
  return proto.ethereum.beacon.rpc.v1.AttestationData.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ethereum.beacon.rpc.v1.AttestationData} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.AttestationData.toObject = function(includeInstance, msg) {
  var f, obj = {
    slot: jspb.Message.getFieldWithDefault(msg, 1, 0),
    shard: jspb.Message.getFieldWithDefault(msg, 2, 0),
    beaconBlockRootHash32: msg.getBeaconBlockRootHash32_asB64(),
    epochBoundaryRootHash32: msg.getEpochBoundaryRootHash32_asB64(),
    crosslinkDataRootHash32: msg.getCrosslinkDataRootHash32_asB64(),
    latestCrosslink: (f = msg.getLatestCrosslink()) && proto.ethereum.beacon.rpc.v1.Crosslink.toObject(includeInstance, f),
    justifiedEpoch: jspb.Message.getFieldWithDefault(msg, 7, 0),
    justifiedBlockRootHash32: msg.getJustifiedBlockRootHash32_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ethereum.beacon.rpc.v1.AttestationData}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ethereum.beacon.rpc.v1.AttestationData;
  return proto.ethereum.beacon.rpc.v1.AttestationData.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ethereum.beacon.rpc.v1.AttestationData} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ethereum.beacon.rpc.v1.AttestationData}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setSlot(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setShard(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBeaconBlockRootHash32(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setEpochBoundaryRootHash32(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setCrosslinkDataRootHash32(value);
      break;
    case 6:
      var value = new proto.ethereum.beacon.rpc.v1.Crosslink;
      reader.readMessage(value,proto.ethereum.beacon.rpc.v1.Crosslink.deserializeBinaryFromReader);
      msg.setLatestCrosslink(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setJustifiedEpoch(value);
      break;
    case 8:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setJustifiedBlockRootHash32(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ethereum.beacon.rpc.v1.AttestationData.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ethereum.beacon.rpc.v1.AttestationData} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.AttestationData.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSlot();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getShard();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getBeaconBlockRootHash32_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getEpochBoundaryRootHash32_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = message.getCrosslinkDataRootHash32_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = message.getLatestCrosslink();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.ethereum.beacon.rpc.v1.Crosslink.serializeBinaryToWriter
    );
  }
  f = message.getJustifiedEpoch();
  if (f !== 0) {
    writer.writeUint64(
      7,
      f
    );
  }
  f = message.getJustifiedBlockRootHash32_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      8,
      f
    );
  }
};


/**
 * optional uint64 slot = 1;
 * @return {number}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.getSlot = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.setSlot = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint64 shard = 2;
 * @return {number}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.getShard = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.setShard = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional bytes beacon_block_root_hash32 = 3;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.getBeaconBlockRootHash32 = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes beacon_block_root_hash32 = 3;
 * This is a type-conversion wrapper around `getBeaconBlockRootHash32()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.getBeaconBlockRootHash32_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBeaconBlockRootHash32()));
};


/**
 * optional bytes beacon_block_root_hash32 = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBeaconBlockRootHash32()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.getBeaconBlockRootHash32_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBeaconBlockRootHash32()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.setBeaconBlockRootHash32 = function(value) {
  jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional bytes epoch_boundary_root_hash32 = 4;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.getEpochBoundaryRootHash32 = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes epoch_boundary_root_hash32 = 4;
 * This is a type-conversion wrapper around `getEpochBoundaryRootHash32()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.getEpochBoundaryRootHash32_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getEpochBoundaryRootHash32()));
};


/**
 * optional bytes epoch_boundary_root_hash32 = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getEpochBoundaryRootHash32()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.getEpochBoundaryRootHash32_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getEpochBoundaryRootHash32()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.setEpochBoundaryRootHash32 = function(value) {
  jspb.Message.setProto3BytesField(this, 4, value);
};


/**
 * optional bytes crosslink_data_root_hash32 = 5;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.getCrosslinkDataRootHash32 = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes crosslink_data_root_hash32 = 5;
 * This is a type-conversion wrapper around `getCrosslinkDataRootHash32()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.getCrosslinkDataRootHash32_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getCrosslinkDataRootHash32()));
};


/**
 * optional bytes crosslink_data_root_hash32 = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getCrosslinkDataRootHash32()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.getCrosslinkDataRootHash32_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getCrosslinkDataRootHash32()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.setCrosslinkDataRootHash32 = function(value) {
  jspb.Message.setProto3BytesField(this, 5, value);
};


/**
 * optional Crosslink latest_crosslink = 6;
 * @return {?proto.ethereum.beacon.rpc.v1.Crosslink}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.getLatestCrosslink = function() {
  return /** @type{?proto.ethereum.beacon.rpc.v1.Crosslink} */ (
    jspb.Message.getWrapperField(this, proto.ethereum.beacon.rpc.v1.Crosslink, 6));
};


/** @param {?proto.ethereum.beacon.rpc.v1.Crosslink|undefined} value */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.setLatestCrosslink = function(value) {
  jspb.Message.setWrapperField(this, 6, value);
};


/**
 * Clears the message field making it undefined.
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.clearLatestCrosslink = function() {
  this.setLatestCrosslink(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.hasLatestCrosslink = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional uint64 justified_epoch = 7;
 * @return {number}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.getJustifiedEpoch = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.setJustifiedEpoch = function(value) {
  jspb.Message.setProto3IntField(this, 7, value);
};


/**
 * optional bytes justified_block_root_hash32 = 8;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.getJustifiedBlockRootHash32 = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/**
 * optional bytes justified_block_root_hash32 = 8;
 * This is a type-conversion wrapper around `getJustifiedBlockRootHash32()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.getJustifiedBlockRootHash32_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getJustifiedBlockRootHash32()));
};


/**
 * optional bytes justified_block_root_hash32 = 8;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getJustifiedBlockRootHash32()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.getJustifiedBlockRootHash32_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getJustifiedBlockRootHash32()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.AttestationData.prototype.setJustifiedBlockRootHash32 = function(value) {
  jspb.Message.setProto3BytesField(this, 8, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ethereum.beacon.rpc.v1.ProposalSignedData.prototype.toObject = function(opt_includeInstance) {
  return proto.ethereum.beacon.rpc.v1.ProposalSignedData.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ethereum.beacon.rpc.v1.ProposalSignedData} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.ProposalSignedData.toObject = function(includeInstance, msg) {
  var f, obj = {
    slot: jspb.Message.getFieldWithDefault(msg, 1, 0),
    shard: jspb.Message.getFieldWithDefault(msg, 2, 0),
    blockRootHash32: msg.getBlockRootHash32_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ethereum.beacon.rpc.v1.ProposalSignedData}
 */
proto.ethereum.beacon.rpc.v1.ProposalSignedData.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ethereum.beacon.rpc.v1.ProposalSignedData;
  return proto.ethereum.beacon.rpc.v1.ProposalSignedData.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ethereum.beacon.rpc.v1.ProposalSignedData} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ethereum.beacon.rpc.v1.ProposalSignedData}
 */
proto.ethereum.beacon.rpc.v1.ProposalSignedData.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setSlot(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setShard(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBlockRootHash32(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.ProposalSignedData.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ethereum.beacon.rpc.v1.ProposalSignedData.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ethereum.beacon.rpc.v1.ProposalSignedData} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.ProposalSignedData.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSlot();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getShard();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getBlockRootHash32_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional uint64 slot = 1;
 * @return {number}
 */
proto.ethereum.beacon.rpc.v1.ProposalSignedData.prototype.getSlot = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.ethereum.beacon.rpc.v1.ProposalSignedData.prototype.setSlot = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint64 shard = 2;
 * @return {number}
 */
proto.ethereum.beacon.rpc.v1.ProposalSignedData.prototype.getShard = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.ethereum.beacon.rpc.v1.ProposalSignedData.prototype.setShard = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional bytes block_root_hash32 = 3;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.ProposalSignedData.prototype.getBlockRootHash32 = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes block_root_hash32 = 3;
 * This is a type-conversion wrapper around `getBlockRootHash32()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.ProposalSignedData.prototype.getBlockRootHash32_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBlockRootHash32()));
};


/**
 * optional bytes block_root_hash32 = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBlockRootHash32()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.ProposalSignedData.prototype.getBlockRootHash32_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBlockRootHash32()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.ProposalSignedData.prototype.setBlockRootHash32 = function(value) {
  jspb.Message.setProto3BytesField(this, 3, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.prototype.toObject = function(opt_includeInstance) {
  return proto.ethereum.beacon.rpc.v1.SlashableAttestation.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ethereum.beacon.rpc.v1.SlashableAttestation} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.toObject = function(includeInstance, msg) {
  var f, obj = {
    validatorIndicesList: jspb.Message.getRepeatedField(msg, 1),
    custodyBitfield: msg.getCustodyBitfield_asB64(),
    data: (f = msg.getData()) && proto.ethereum.beacon.rpc.v1.AttestationData.toObject(includeInstance, f),
    aggregateSignature: msg.getAggregateSignature_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ethereum.beacon.rpc.v1.SlashableAttestation}
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ethereum.beacon.rpc.v1.SlashableAttestation;
  return proto.ethereum.beacon.rpc.v1.SlashableAttestation.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ethereum.beacon.rpc.v1.SlashableAttestation} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ethereum.beacon.rpc.v1.SlashableAttestation}
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Array<number>} */ (reader.readPackedUint64());
      msg.setValidatorIndicesList(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setCustodyBitfield(value);
      break;
    case 3:
      var value = new proto.ethereum.beacon.rpc.v1.AttestationData;
      reader.readMessage(value,proto.ethereum.beacon.rpc.v1.AttestationData.deserializeBinaryFromReader);
      msg.setData(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setAggregateSignature(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ethereum.beacon.rpc.v1.SlashableAttestation.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ethereum.beacon.rpc.v1.SlashableAttestation} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValidatorIndicesList();
  if (f.length > 0) {
    writer.writePackedUint64(
      1,
      f
    );
  }
  f = message.getCustodyBitfield_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getData();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.ethereum.beacon.rpc.v1.AttestationData.serializeBinaryToWriter
    );
  }
  f = message.getAggregateSignature_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
};


/**
 * repeated uint64 validator_indices = 1;
 * @return {!Array<number>}
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.prototype.getValidatorIndicesList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array<number>} value */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.prototype.setValidatorIndicesList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {number} value
 * @param {number=} opt_index
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.prototype.addValidatorIndices = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.prototype.clearValidatorIndicesList = function() {
  this.setValidatorIndicesList([]);
};


/**
 * optional bytes custody_bitfield = 2;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.prototype.getCustodyBitfield = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes custody_bitfield = 2;
 * This is a type-conversion wrapper around `getCustodyBitfield()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.prototype.getCustodyBitfield_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getCustodyBitfield()));
};


/**
 * optional bytes custody_bitfield = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getCustodyBitfield()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.prototype.getCustodyBitfield_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getCustodyBitfield()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.prototype.setCustodyBitfield = function(value) {
  jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional AttestationData data = 3;
 * @return {?proto.ethereum.beacon.rpc.v1.AttestationData}
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.prototype.getData = function() {
  return /** @type{?proto.ethereum.beacon.rpc.v1.AttestationData} */ (
    jspb.Message.getWrapperField(this, proto.ethereum.beacon.rpc.v1.AttestationData, 3));
};


/** @param {?proto.ethereum.beacon.rpc.v1.AttestationData|undefined} value */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.prototype.setData = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.prototype.clearData = function() {
  this.setData(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.prototype.hasData = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional bytes aggregate_signature = 4;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.prototype.getAggregateSignature = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes aggregate_signature = 4;
 * This is a type-conversion wrapper around `getAggregateSignature()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.prototype.getAggregateSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getAggregateSignature()));
};


/**
 * optional bytes aggregate_signature = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getAggregateSignature()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.prototype.getAggregateSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getAggregateSignature()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.SlashableAttestation.prototype.setAggregateSignature = function(value) {
  jspb.Message.setProto3BytesField(this, 4, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.toObject = function(opt_includeInstance) {
  return proto.ethereum.beacon.rpc.v1.ProposerSlashing.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ethereum.beacon.rpc.v1.ProposerSlashing} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.toObject = function(includeInstance, msg) {
  var f, obj = {
    proposerIndex: jspb.Message.getFieldWithDefault(msg, 1, 0),
    proposalData1: (f = msg.getProposalData1()) && proto.ethereum.beacon.rpc.v1.ProposalSignedData.toObject(includeInstance, f),
    proposalSignature1: msg.getProposalSignature1_asB64(),
    proposalData2: (f = msg.getProposalData2()) && proto.ethereum.beacon.rpc.v1.ProposalSignedData.toObject(includeInstance, f),
    proposalSignature2: msg.getProposalSignature2_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ethereum.beacon.rpc.v1.ProposerSlashing}
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ethereum.beacon.rpc.v1.ProposerSlashing;
  return proto.ethereum.beacon.rpc.v1.ProposerSlashing.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ethereum.beacon.rpc.v1.ProposerSlashing} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ethereum.beacon.rpc.v1.ProposerSlashing}
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setProposerIndex(value);
      break;
    case 2:
      var value = new proto.ethereum.beacon.rpc.v1.ProposalSignedData;
      reader.readMessage(value,proto.ethereum.beacon.rpc.v1.ProposalSignedData.deserializeBinaryFromReader);
      msg.setProposalData1(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setProposalSignature1(value);
      break;
    case 4:
      var value = new proto.ethereum.beacon.rpc.v1.ProposalSignedData;
      reader.readMessage(value,proto.ethereum.beacon.rpc.v1.ProposalSignedData.deserializeBinaryFromReader);
      msg.setProposalData2(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setProposalSignature2(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ethereum.beacon.rpc.v1.ProposerSlashing.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ethereum.beacon.rpc.v1.ProposerSlashing} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getProposerIndex();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getProposalData1();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.ethereum.beacon.rpc.v1.ProposalSignedData.serializeBinaryToWriter
    );
  }
  f = message.getProposalSignature1_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getProposalData2();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.ethereum.beacon.rpc.v1.ProposalSignedData.serializeBinaryToWriter
    );
  }
  f = message.getProposalSignature2_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
};


/**
 * optional uint64 proposer_index = 1;
 * @return {number}
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.getProposerIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.setProposerIndex = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional ProposalSignedData proposal_data_1 = 2;
 * @return {?proto.ethereum.beacon.rpc.v1.ProposalSignedData}
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.getProposalData1 = function() {
  return /** @type{?proto.ethereum.beacon.rpc.v1.ProposalSignedData} */ (
    jspb.Message.getWrapperField(this, proto.ethereum.beacon.rpc.v1.ProposalSignedData, 2));
};


/** @param {?proto.ethereum.beacon.rpc.v1.ProposalSignedData|undefined} value */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.setProposalData1 = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.clearProposalData1 = function() {
  this.setProposalData1(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.hasProposalData1 = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes proposal_signature_1 = 3;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.getProposalSignature1 = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes proposal_signature_1 = 3;
 * This is a type-conversion wrapper around `getProposalSignature1()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.getProposalSignature1_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getProposalSignature1()));
};


/**
 * optional bytes proposal_signature_1 = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getProposalSignature1()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.getProposalSignature1_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getProposalSignature1()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.setProposalSignature1 = function(value) {
  jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional ProposalSignedData proposal_data_2 = 4;
 * @return {?proto.ethereum.beacon.rpc.v1.ProposalSignedData}
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.getProposalData2 = function() {
  return /** @type{?proto.ethereum.beacon.rpc.v1.ProposalSignedData} */ (
    jspb.Message.getWrapperField(this, proto.ethereum.beacon.rpc.v1.ProposalSignedData, 4));
};


/** @param {?proto.ethereum.beacon.rpc.v1.ProposalSignedData|undefined} value */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.setProposalData2 = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.clearProposalData2 = function() {
  this.setProposalData2(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.hasProposalData2 = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional bytes proposal_signature_2 = 5;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.getProposalSignature2 = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes proposal_signature_2 = 5;
 * This is a type-conversion wrapper around `getProposalSignature2()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.getProposalSignature2_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getProposalSignature2()));
};


/**
 * optional bytes proposal_signature_2 = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getProposalSignature2()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.getProposalSignature2_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getProposalSignature2()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.ProposerSlashing.prototype.setProposalSignature2 = function(value) {
  jspb.Message.setProto3BytesField(this, 5, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ethereum.beacon.rpc.v1.AttesterSlashing.prototype.toObject = function(opt_includeInstance) {
  return proto.ethereum.beacon.rpc.v1.AttesterSlashing.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ethereum.beacon.rpc.v1.AttesterSlashing} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.AttesterSlashing.toObject = function(includeInstance, msg) {
  var f, obj = {
    slashableAttestation1: (f = msg.getSlashableAttestation1()) && proto.ethereum.beacon.rpc.v1.SlashableAttestation.toObject(includeInstance, f),
    slashableAttestation2: (f = msg.getSlashableAttestation2()) && proto.ethereum.beacon.rpc.v1.SlashableAttestation.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ethereum.beacon.rpc.v1.AttesterSlashing}
 */
proto.ethereum.beacon.rpc.v1.AttesterSlashing.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ethereum.beacon.rpc.v1.AttesterSlashing;
  return proto.ethereum.beacon.rpc.v1.AttesterSlashing.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ethereum.beacon.rpc.v1.AttesterSlashing} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ethereum.beacon.rpc.v1.AttesterSlashing}
 */
proto.ethereum.beacon.rpc.v1.AttesterSlashing.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.ethereum.beacon.rpc.v1.SlashableAttestation;
      reader.readMessage(value,proto.ethereum.beacon.rpc.v1.SlashableAttestation.deserializeBinaryFromReader);
      msg.setSlashableAttestation1(value);
      break;
    case 2:
      var value = new proto.ethereum.beacon.rpc.v1.SlashableAttestation;
      reader.readMessage(value,proto.ethereum.beacon.rpc.v1.SlashableAttestation.deserializeBinaryFromReader);
      msg.setSlashableAttestation2(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.AttesterSlashing.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ethereum.beacon.rpc.v1.AttesterSlashing.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ethereum.beacon.rpc.v1.AttesterSlashing} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.AttesterSlashing.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSlashableAttestation1();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.ethereum.beacon.rpc.v1.SlashableAttestation.serializeBinaryToWriter
    );
  }
  f = message.getSlashableAttestation2();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.ethereum.beacon.rpc.v1.SlashableAttestation.serializeBinaryToWriter
    );
  }
};


/**
 * optional SlashableAttestation slashable_attestation_1 = 1;
 * @return {?proto.ethereum.beacon.rpc.v1.SlashableAttestation}
 */
proto.ethereum.beacon.rpc.v1.AttesterSlashing.prototype.getSlashableAttestation1 = function() {
  return /** @type{?proto.ethereum.beacon.rpc.v1.SlashableAttestation} */ (
    jspb.Message.getWrapperField(this, proto.ethereum.beacon.rpc.v1.SlashableAttestation, 1));
};


/** @param {?proto.ethereum.beacon.rpc.v1.SlashableAttestation|undefined} value */
proto.ethereum.beacon.rpc.v1.AttesterSlashing.prototype.setSlashableAttestation1 = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 */
proto.ethereum.beacon.rpc.v1.AttesterSlashing.prototype.clearSlashableAttestation1 = function() {
  this.setSlashableAttestation1(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ethereum.beacon.rpc.v1.AttesterSlashing.prototype.hasSlashableAttestation1 = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional SlashableAttestation slashable_attestation_2 = 2;
 * @return {?proto.ethereum.beacon.rpc.v1.SlashableAttestation}
 */
proto.ethereum.beacon.rpc.v1.AttesterSlashing.prototype.getSlashableAttestation2 = function() {
  return /** @type{?proto.ethereum.beacon.rpc.v1.SlashableAttestation} */ (
    jspb.Message.getWrapperField(this, proto.ethereum.beacon.rpc.v1.SlashableAttestation, 2));
};


/** @param {?proto.ethereum.beacon.rpc.v1.SlashableAttestation|undefined} value */
proto.ethereum.beacon.rpc.v1.AttesterSlashing.prototype.setSlashableAttestation2 = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 */
proto.ethereum.beacon.rpc.v1.AttesterSlashing.prototype.clearSlashableAttestation2 = function() {
  this.setSlashableAttestation2(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ethereum.beacon.rpc.v1.AttesterSlashing.prototype.hasSlashableAttestation2 = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ethereum.beacon.rpc.v1.Crosslink.prototype.toObject = function(opt_includeInstance) {
  return proto.ethereum.beacon.rpc.v1.Crosslink.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ethereum.beacon.rpc.v1.Crosslink} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.Crosslink.toObject = function(includeInstance, msg) {
  var f, obj = {
    epoch: jspb.Message.getFieldWithDefault(msg, 1, 0),
    crosslinkDataRootHash32: msg.getCrosslinkDataRootHash32_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ethereum.beacon.rpc.v1.Crosslink}
 */
proto.ethereum.beacon.rpc.v1.Crosslink.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ethereum.beacon.rpc.v1.Crosslink;
  return proto.ethereum.beacon.rpc.v1.Crosslink.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ethereum.beacon.rpc.v1.Crosslink} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ethereum.beacon.rpc.v1.Crosslink}
 */
proto.ethereum.beacon.rpc.v1.Crosslink.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setEpoch(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setCrosslinkDataRootHash32(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.Crosslink.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ethereum.beacon.rpc.v1.Crosslink.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ethereum.beacon.rpc.v1.Crosslink} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.Crosslink.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEpoch();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getCrosslinkDataRootHash32_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional uint64 epoch = 1;
 * @return {number}
 */
proto.ethereum.beacon.rpc.v1.Crosslink.prototype.getEpoch = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.ethereum.beacon.rpc.v1.Crosslink.prototype.setEpoch = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional bytes crosslink_data_root_hash32 = 2;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.Crosslink.prototype.getCrosslinkDataRootHash32 = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes crosslink_data_root_hash32 = 2;
 * This is a type-conversion wrapper around `getCrosslinkDataRootHash32()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.Crosslink.prototype.getCrosslinkDataRootHash32_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getCrosslinkDataRootHash32()));
};


/**
 * optional bytes crosslink_data_root_hash32 = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getCrosslinkDataRootHash32()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.Crosslink.prototype.getCrosslinkDataRootHash32_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getCrosslinkDataRootHash32()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.Crosslink.prototype.setCrosslinkDataRootHash32 = function(value) {
  jspb.Message.setProto3BytesField(this, 2, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.ethereum.beacon.rpc.v1.Deposit.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ethereum.beacon.rpc.v1.Deposit.prototype.toObject = function(opt_includeInstance) {
  return proto.ethereum.beacon.rpc.v1.Deposit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ethereum.beacon.rpc.v1.Deposit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.Deposit.toObject = function(includeInstance, msg) {
  var f, obj = {
    merkleProofHash32sList: msg.getMerkleProofHash32sList_asB64(),
    merkleTreeIndex: jspb.Message.getFieldWithDefault(msg, 2, 0),
    depositData: msg.getDepositData_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ethereum.beacon.rpc.v1.Deposit}
 */
proto.ethereum.beacon.rpc.v1.Deposit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ethereum.beacon.rpc.v1.Deposit;
  return proto.ethereum.beacon.rpc.v1.Deposit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ethereum.beacon.rpc.v1.Deposit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ethereum.beacon.rpc.v1.Deposit}
 */
proto.ethereum.beacon.rpc.v1.Deposit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addMerkleProofHash32s(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setMerkleTreeIndex(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setDepositData(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.Deposit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ethereum.beacon.rpc.v1.Deposit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ethereum.beacon.rpc.v1.Deposit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.Deposit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMerkleProofHash32sList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      1,
      f
    );
  }
  f = message.getMerkleTreeIndex();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getDepositData_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * repeated bytes merkle_proof_hash32s = 1;
 * @return {!Array<string>}
 */
proto.ethereum.beacon.rpc.v1.Deposit.prototype.getMerkleProofHash32sList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 1));
};


/**
 * repeated bytes merkle_proof_hash32s = 1;
 * This is a type-conversion wrapper around `getMerkleProofHash32sList()`
 * @return {!Array<string>}
 */
proto.ethereum.beacon.rpc.v1.Deposit.prototype.getMerkleProofHash32sList_asB64 = function() {
  return /** @type {!Array<string>} */ (jspb.Message.bytesListAsB64(
      this.getMerkleProofHash32sList()));
};


/**
 * repeated bytes merkle_proof_hash32s = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMerkleProofHash32sList()`
 * @return {!Array<!Uint8Array>}
 */
proto.ethereum.beacon.rpc.v1.Deposit.prototype.getMerkleProofHash32sList_asU8 = function() {
  return /** @type {!Array<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getMerkleProofHash32sList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value */
proto.ethereum.beacon.rpc.v1.Deposit.prototype.setMerkleProofHash32sList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 */
proto.ethereum.beacon.rpc.v1.Deposit.prototype.addMerkleProofHash32s = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 */
proto.ethereum.beacon.rpc.v1.Deposit.prototype.clearMerkleProofHash32sList = function() {
  this.setMerkleProofHash32sList([]);
};


/**
 * optional uint64 merkle_tree_index = 2;
 * @return {number}
 */
proto.ethereum.beacon.rpc.v1.Deposit.prototype.getMerkleTreeIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.ethereum.beacon.rpc.v1.Deposit.prototype.setMerkleTreeIndex = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional bytes deposit_data = 3;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.Deposit.prototype.getDepositData = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes deposit_data = 3;
 * This is a type-conversion wrapper around `getDepositData()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.Deposit.prototype.getDepositData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getDepositData()));
};


/**
 * optional bytes deposit_data = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getDepositData()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.Deposit.prototype.getDepositData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getDepositData()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.Deposit.prototype.setDepositData = function(value) {
  jspb.Message.setProto3BytesField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ethereum.beacon.rpc.v1.VoluntaryExit.prototype.toObject = function(opt_includeInstance) {
  return proto.ethereum.beacon.rpc.v1.VoluntaryExit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ethereum.beacon.rpc.v1.VoluntaryExit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.VoluntaryExit.toObject = function(includeInstance, msg) {
  var f, obj = {
    epoch: jspb.Message.getFieldWithDefault(msg, 1, 0),
    validatorIndex: jspb.Message.getFieldWithDefault(msg, 2, 0),
    signature: msg.getSignature_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ethereum.beacon.rpc.v1.VoluntaryExit}
 */
proto.ethereum.beacon.rpc.v1.VoluntaryExit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ethereum.beacon.rpc.v1.VoluntaryExit;
  return proto.ethereum.beacon.rpc.v1.VoluntaryExit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ethereum.beacon.rpc.v1.VoluntaryExit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ethereum.beacon.rpc.v1.VoluntaryExit}
 */
proto.ethereum.beacon.rpc.v1.VoluntaryExit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setEpoch(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setValidatorIndex(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.VoluntaryExit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ethereum.beacon.rpc.v1.VoluntaryExit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ethereum.beacon.rpc.v1.VoluntaryExit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.VoluntaryExit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEpoch();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getValidatorIndex();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getSignature_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional uint64 epoch = 1;
 * @return {number}
 */
proto.ethereum.beacon.rpc.v1.VoluntaryExit.prototype.getEpoch = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.ethereum.beacon.rpc.v1.VoluntaryExit.prototype.setEpoch = function(value) {
  jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint64 validator_index = 2;
 * @return {number}
 */
proto.ethereum.beacon.rpc.v1.VoluntaryExit.prototype.getValidatorIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.ethereum.beacon.rpc.v1.VoluntaryExit.prototype.setValidatorIndex = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional bytes signature = 3;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.VoluntaryExit.prototype.getSignature = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes signature = 3;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.VoluntaryExit.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.VoluntaryExit.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.VoluntaryExit.prototype.setSignature = function(value) {
  jspb.Message.setProto3BytesField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ethereum.beacon.rpc.v1.Eth1Data.prototype.toObject = function(opt_includeInstance) {
  return proto.ethereum.beacon.rpc.v1.Eth1Data.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ethereum.beacon.rpc.v1.Eth1Data} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.Eth1Data.toObject = function(includeInstance, msg) {
  var f, obj = {
    depositRootHash32: msg.getDepositRootHash32_asB64(),
    blockHash32: msg.getBlockHash32_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ethereum.beacon.rpc.v1.Eth1Data}
 */
proto.ethereum.beacon.rpc.v1.Eth1Data.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ethereum.beacon.rpc.v1.Eth1Data;
  return proto.ethereum.beacon.rpc.v1.Eth1Data.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ethereum.beacon.rpc.v1.Eth1Data} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ethereum.beacon.rpc.v1.Eth1Data}
 */
proto.ethereum.beacon.rpc.v1.Eth1Data.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setDepositRootHash32(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBlockHash32(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.Eth1Data.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ethereum.beacon.rpc.v1.Eth1Data.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ethereum.beacon.rpc.v1.Eth1Data} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.Eth1Data.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDepositRootHash32_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getBlockHash32_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional bytes deposit_root_hash32 = 1;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.Eth1Data.prototype.getDepositRootHash32 = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes deposit_root_hash32 = 1;
 * This is a type-conversion wrapper around `getDepositRootHash32()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.Eth1Data.prototype.getDepositRootHash32_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getDepositRootHash32()));
};


/**
 * optional bytes deposit_root_hash32 = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getDepositRootHash32()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.Eth1Data.prototype.getDepositRootHash32_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getDepositRootHash32()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.Eth1Data.prototype.setDepositRootHash32 = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional bytes block_hash32 = 2;
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.Eth1Data.prototype.getBlockHash32 = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes block_hash32 = 2;
 * This is a type-conversion wrapper around `getBlockHash32()`
 * @return {string}
 */
proto.ethereum.beacon.rpc.v1.Eth1Data.prototype.getBlockHash32_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBlockHash32()));
};


/**
 * optional bytes block_hash32 = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBlockHash32()`
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.Eth1Data.prototype.getBlockHash32_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBlockHash32()));
};


/** @param {!(string|Uint8Array)} value */
proto.ethereum.beacon.rpc.v1.Eth1Data.prototype.setBlockHash32 = function(value) {
  jspb.Message.setProto3BytesField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ethereum.beacon.rpc.v1.Eth1DataVote.prototype.toObject = function(opt_includeInstance) {
  return proto.ethereum.beacon.rpc.v1.Eth1DataVote.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ethereum.beacon.rpc.v1.Eth1DataVote} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.Eth1DataVote.toObject = function(includeInstance, msg) {
  var f, obj = {
    eth1Data: (f = msg.getEth1Data()) && proto.ethereum.beacon.rpc.v1.Eth1Data.toObject(includeInstance, f),
    voteCount: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ethereum.beacon.rpc.v1.Eth1DataVote}
 */
proto.ethereum.beacon.rpc.v1.Eth1DataVote.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ethereum.beacon.rpc.v1.Eth1DataVote;
  return proto.ethereum.beacon.rpc.v1.Eth1DataVote.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ethereum.beacon.rpc.v1.Eth1DataVote} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ethereum.beacon.rpc.v1.Eth1DataVote}
 */
proto.ethereum.beacon.rpc.v1.Eth1DataVote.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.ethereum.beacon.rpc.v1.Eth1Data;
      reader.readMessage(value,proto.ethereum.beacon.rpc.v1.Eth1Data.deserializeBinaryFromReader);
      msg.setEth1Data(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setVoteCount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ethereum.beacon.rpc.v1.Eth1DataVote.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ethereum.beacon.rpc.v1.Eth1DataVote.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ethereum.beacon.rpc.v1.Eth1DataVote} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ethereum.beacon.rpc.v1.Eth1DataVote.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEth1Data();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.ethereum.beacon.rpc.v1.Eth1Data.serializeBinaryToWriter
    );
  }
  f = message.getVoteCount();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
};


/**
 * optional Eth1Data eth1_data = 1;
 * @return {?proto.ethereum.beacon.rpc.v1.Eth1Data}
 */
proto.ethereum.beacon.rpc.v1.Eth1DataVote.prototype.getEth1Data = function() {
  return /** @type{?proto.ethereum.beacon.rpc.v1.Eth1Data} */ (
    jspb.Message.getWrapperField(this, proto.ethereum.beacon.rpc.v1.Eth1Data, 1));
};


/** @param {?proto.ethereum.beacon.rpc.v1.Eth1Data|undefined} value */
proto.ethereum.beacon.rpc.v1.Eth1DataVote.prototype.setEth1Data = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 */
proto.ethereum.beacon.rpc.v1.Eth1DataVote.prototype.clearEth1Data = function() {
  this.setEth1Data(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ethereum.beacon.rpc.v1.Eth1DataVote.prototype.hasEth1Data = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint64 vote_count = 2;
 * @return {number}
 */
proto.ethereum.beacon.rpc.v1.Eth1DataVote.prototype.getVoteCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.ethereum.beacon.rpc.v1.Eth1DataVote.prototype.setVoteCount = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};


goog.object.extend(exports, proto.ethereum.beacon.rpc.v1);
